{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/FusionSwapIntentERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.30;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n/// @title Cross-Chain Atomic Swap Intent ERC20 (Fusion+ Compatible)\r\n/// @notice Contrato para swaps atómicos con hashlock y timelock que\r\n///         puede usarse en flujos cross-chain con relayers como Fusion+.\r\ncontract FusionSwapIntentERC20 {\r\n    address public sender; // Quien crea el swap (y puede pedir reembolso)\r\n    address public receiver; // Quien recibe los fondos si revela el secreto\r\n    bytes32 public hashlock; // keccak256(secreto)\r\n    uint256 public timelock; // Expiración Unix timestamp\r\n    uint256 public amount; // Tokens bloqueados\r\n    IERC20 public token; // Token ERC-20\r\n    bool public withdrawn; // Swap ejecutado con éxito\r\n    bool public refunded; // Reembolso ejecutado\r\n\r\n    event SwapIntentCreated(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address indexed token,\r\n        bytes32 hashlock,\r\n        uint256 timelock,\r\n        uint256 amount\r\n    );\r\n\r\n    event SecretRevealed(bytes32 secret);\r\n    event SwapExecuted(address executor, bytes32 secret);\r\n    event SwapRefunded();\r\n\r\n    constructor(\r\n        address _sender,\r\n        bytes32 _hashlock,\r\n        uint256 _timelockSeconds,\r\n        address _receiver,\r\n        address _token,\r\n        uint256 _amount\r\n    ) {\r\n        require(_sender != address(0), \"Invalid sender\");\r\n        require(_receiver != address(0), \"Invalid receiver\");\r\n        require(_token != address(0), \"Invalid token\");\r\n        require(_amount > 0, \"Amount must be > 0\");\r\n        require(_timelockSeconds > 0, \"Timelock must be positive\");\r\n\r\n        sender = _sender;\r\n        receiver = _receiver;\r\n        hashlock = _hashlock;\r\n        timelock = block.timestamp + _timelockSeconds;\r\n        token = IERC20(_token);\r\n        amount = _amount;\r\n\r\n        emit SwapIntentCreated(_sender, _receiver, _token, _hashlock, timelock, _amount);\r\n    }\r\n\r\n    /// @notice Publica el secreto para que solvers lo usen en otra cadena\r\n    ///         (ej. para completar el swap en Optimism si se reveló en Etherlink)\r\n    function revealSecret(bytes32 _secret) external {\r\n        require(keccak256(abi.encodePacked(_secret)) == hashlock, \"Invalid secret\");\r\n        emit SecretRevealed(_secret);\r\n    }\r\n\r\n    /// @notice Ejecuta el swap si se conoce el secreto.\r\n    /// @dev Abierto para cualquier executor que tenga el preimagen válida.\r\n    function executeSwap(bytes32 _secret) external {\r\n        require(!withdrawn, \"Already executed\");\r\n        require(!refunded, \"Already refunded\");\r\n        require(keccak256(abi.encodePacked(_secret)) == hashlock, \"Invalid secret\");\r\n\r\n        withdrawn = true;\r\n        require(token.transfer(receiver, amount), \"Token transfer failed\");\r\n        emit SwapExecuted(msg.sender, _secret);\r\n    }\r\n\r\n    /// @notice Permite al sender reembolsar si nadie reveló el secreto antes del timelock.\r\n    function refundSwap() external {\r\n        require(block.timestamp > timelock, \"Timelock not expired\");\r\n        require(msg.sender == sender, \"Only sender can refund\");\r\n        require(!withdrawn, \"Already executed\");\r\n        require(!refunded, \"Already refunded\");\r\n\r\n        refunded = true;\r\n        require(token.transfer(sender, amount), \"Refund failed\");\r\n        emit SwapRefunded();\r\n    }\r\n\r\n    /// @return Estado actual como texto\r\n    function getSwapStatus() external view returns (string memory) {\r\n        if (withdrawn) return \"Completed\";\r\n        if (refunded) return \"Refunded\";\r\n        return \"Pending\";\r\n    }\r\n}\r\n\r\n"
    },
    "contracts/SwapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./FusionSwapIntentERC20.sol\";\r\n\r\n/// @title SwapFactory para desplegar y gestionar instancias de FusionSwapIntentERC20\r\n/// @notice Permite la creación estandarizada de nuevos swaps atómicos ERC-20\r\n///         y centraliza el depósito inicial de tokens del usuario.\r\ncontract SwapFactory {\r\n    //states\r\n    address[] public allSwaps;\r\n\r\n    //events\r\n    event SwapCreated(\r\n        address swapAddress,     \r\n        address indexed creator, \r\n        address indexed receiver, \r\n        address indexed token,    // La dirección del token ERC-20\r\n        uint256 amount,     \r\n        uint256 timelockEnd       // El timestamp Unix de finalización del timelock\r\n    );\r\n\r\n    /// @notice Crea una nueva instancia del contrato FusionSwapIntentERC20.\r\n    ///         El usuario (msg.sender) debe haber APROBADO previamente\r\n    ///         que esta Factory pueda gastar sus 'amount' de 'tokenAddress'.\r\n    /// @param hashlock El hash keccak256 del secreto compartido.\r\n    /// @param timelockSeconds Duración del timelock en segundos.\r\n    /// @param receiver Dirección que recibirá los tokens si presenta el secreto.\r\n    /// @param tokenAddress Dirección del contrato del token ERC-20 a intercambiar.\r\n    /// @param amount Cantidad de tokens a intercambiar.\r\n    function createSwap(\r\n        bytes32 hashlock,\r\n        uint256 timelockSeconds,\r\n        address receiver,\r\n        address tokenAddress,\r\n        uint256 amount\r\n    ) external {\r\n        // Validaciones iniciales\r\n        require(amount > 0, \"Amount must be greater than zero.\");\r\n        require(receiver != address(0), \"Receiver address required.\");\r\n        require(tokenAddress != address(0), \"Token address required.\");\r\n        require(timelockSeconds > 0, \"Timelock must be positive.\");\r\n\r\n        IERC20 tokenInstance = IERC20(tokenAddress);\r\n\r\n        // Paso 1: Mover los tokens del USUARIO (msg.sender) a la Factory.\r\n        // El usuario debe haber llamado a token.approve(address(this), amount) ANTES de llamar a esta función.\r\n        require(\r\n            tokenInstance.transferFrom(msg.sender, address(this), amount),\r\n            \"Token transfer from user to factory failed. Check allowance.\"\r\n        );\r\n\r\n        // Paso 2: Crear la nueva instancia del contrato FusionSwapIntentERC20.\r\n        // Pasamos msg.sender como el '_sender' original para el FusionSwapIntentERC20\r\n        // para que ese contrato sepa quién tiene los derechos de reembolso.\r\n        FusionSwapIntentERC20 newSwap = new FusionSwapIntentERC20(\r\n            msg.sender,         \r\n            hashlock,\r\n            timelockSeconds,\r\n            receiver,\r\n            tokenAddress,\r\n            amount\r\n        );\r\n\r\n        // Paso 3: Mover los tokens de la Factory al nuevo contrato de swap.\r\n        // Ahora los tokens están en la Factory, y se transfieren al contrato de swap recién creado.\r\n        require(\r\n            tokenInstance.transfer(address(newSwap), amount),\r\n            \"Token transfer from factory to new swap contract failed.\"\r\n        );\r\n\r\n        // Almacenar la dirección del nuevo contrato de swap\r\n        allSwaps.push(address(newSwap));\r\n\r\n        emit SwapCreated(\r\n            address(newSwap),\r\n            msg.sender,\r\n            receiver,\r\n            tokenAddress,\r\n            amount,\r\n            block.timestamp + timelockSeconds\r\n        );\r\n    }\r\n\r\n    function getSwapCount() external view returns (uint256) {\r\n        return allSwaps.length;\r\n    }\r\n\r\n    function getSwapAddress(uint256 index) external view returns (address) {\r\n        require(index < allSwaps.length, \"Invalid index.\");\r\n        return allSwaps[index];\r\n    }\r\n\r\n    function getAllSwaps() external view returns (address[] memory) {\r\n        return allSwaps;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}