{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/AtomicSwapIntentERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Importa la interfaz estándar ERC-20\r\n\r\n/// @title Atomic Swap with Hashlock/Timelock for ERC-20 Tokens\r\n/// @notice Este contrato facilita un swap atómico de tokens ERC-20 con hashlock y timelock.\r\n///         Está diseñado para operar en UNA SOLA CADENA. Los tokens deben ser\r\n///         enviados a este contrato externamente (ej. por un Factory).\r\ncontract AtomicSwapIntentERC20 {\r\n    // Declaración de variables de estado\r\n    address public sender;          // La dirección que inicia el swap y \"posee\" los tokens inicialmente\r\n    address public receiver;        // La dirección que puede reclamar los tokens con el secreto\r\n    address public executor;        // Dirección autorizada para ejecutar el swap (ej: un solver de 1inch Fusion+)\r\n    bytes32 public hashlock;        // El hash del secreto (keccak256(secreto))\r\n    uint256 public timelock;        // El timestamp Unix después del cual el remitente puede reclamar\r\n    uint256 public amount;          // La cantidad de tokens ERC-20 bloqueados\r\n    bool public withdrawn;          // Indica si el receptor ya retiró los tokens\r\n    bool public refunded;           // Indica si el remitente ya reclamó un reembolso\r\n    IERC20 public token;            // La interfaz del contrato del token ERC-20 que se está utilizando\r\n\r\n    // Eventos para rastrear el ciclo de vida del swap\r\n    event SwapIntentCreated(\r\n        address indexed sender,\r\n        address indexed receiver,\r\n        address indexed tokenAddress,\r\n        bytes32 hashlock,\r\n        uint256 timelock,\r\n        uint256 amount,\r\n        address executor\r\n    );\r\n    event SwapExecuted(bytes32 secret);\r\n    event SwapRefunded();\r\n\r\n    /// @notice Constructor para crear una nueva instancia de swap atómico de tokens ERC-20.\r\n    ///         Este constructor es llamado por la Factory, que a su vez recibió los tokens del usuario.\r\n    /// @param _sender La dirección del usuario original que inició el swap.\r\n    /// @param _hashlock El hash del secreto pre-imagen.\r\n    /// @param _timelockSeconds El número de segundos desde la creación después del cual el remitente puede reembolsar.\r\n    /// @param _receiver La dirección que puede ejecutar el swap con el secreto.\r\n    /// @param _executor La dirección que tiene permiso para ejecutar el swap, además del receptor.\r\n    /// @param _tokenAddress La dirección del contrato del token ERC-20 a intercambiar.\r\n    /// @param _amount La cantidad de tokens ERC-20 a bloquear.\r\n    constructor(\r\n        address _sender,            // Nuevo: para almacenar la dirección original del usuario\r\n        bytes32 _hashlock,\r\n        uint256 _timelockSeconds,\r\n        address _receiver,\r\n        address _executor,\r\n        address _tokenAddress,\r\n        uint256 _amount\r\n    ) {\r\n        // Validaciones iniciales\r\n        require(_amount > 0, \"Amount must be greater than zero.\");\r\n        require(_sender != address(0), \"Sender address cannot be zero.\"); // Validamos el sender original\r\n        require(_receiver != address(0), \"Receiver address cannot be zero.\");\r\n        require(_executor != address(0), \"Executor address cannot be zero.\");\r\n        require(_tokenAddress != address(0), \"Token address cannot be zero.\");\r\n        require(_timelockSeconds > 0, \"Timelock must be positive.\");\r\n\r\n        // Asignación de variables de estado\r\n        sender = _sender; // Almacenamos el sender original del usuario\r\n        receiver = _receiver;\r\n        executor = _executor;\r\n        hashlock = _hashlock;\r\n        timelock = block.timestamp + _timelockSeconds;\r\n        amount = _amount;\r\n        token = IERC20(_tokenAddress); // Inicializa la interfaz del token\r\n\r\n        // NOTA: La transferencia de tokens del usuario a este contrato es manejada\r\n        //       por el contrato Factory que despliega esta instancia.\r\n        //       No hay un 'transferFrom' aquí.\r\n\r\n        // Emitir evento para registrar la creación del swap\r\n        emit SwapIntentCreated(sender, receiver, _tokenAddress, hashlock, timelock, amount, executor);\r\n    }\r\n\r\n    /// @notice Permite al receptor o al ejecutor ejecutar el swap y reclamar los tokens.\r\n    /// @param _secret El secreto pre-imagen que se hasheó para obtener el hashlock.\r\n    function executeSwap(bytes32 _secret) external {\r\n        // Validaciones para la ejecución\r\n        require(!withdrawn, \"Already withdrawn.\");\r\n        require(!refunded, \"Already refunded.\");\r\n        require(\r\n            msg.sender == receiver || msg.sender == executor,\r\n            \"Unauthorized executor or receiver.\"\r\n        );\r\n        require(keccak256(abi.encodePacked(_secret)) == hashlock, \"Invalid secret.\");\r\n\r\n        // Marcar como retirado y transferir los tokens al receptor\r\n        withdrawn = true;\r\n        // El token.balanceOf(address(this)) debe ser al menos 'amount' aquí.\r\n        // Esto es garantizado por la factory que lo transfirió previamente.\r\n        require(token.transfer(receiver, amount), \"Token transfer failed during execution.\");\r\n        emit SwapExecuted(_secret);\r\n    }\r\n\r\n    /// @notice Permite al remitente original reembolsar sus tokens si el timelock ha expirado\r\n    ///         y el swap no fue ejecutado.\r\n    function refundSwap() external {\r\n        // Validaciones para el reembolso\r\n        require(block.timestamp > timelock, \"Timelock not expired.\");\r\n        require(msg.sender == sender, \"Only sender can refund.\"); // msg.sender es el sender original\r\n        require(!withdrawn, \"Already withdrawn.\");\r\n        require(!refunded, \"Already refunded.\");\r\n\r\n        // Marcar como reembolsado y transferir los tokens de vuelta al remitente\r\n        refunded = true;\r\n        require(token.transfer(sender, amount), \"Token refund failed.\");\r\n        emit SwapRefunded();\r\n    }\r\n\r\n    /// @notice Devuelve el tiempo restante hasta que el timelock expire.\r\n    /// @return El tiempo restante en segundos.\r\n    function getRemainingTime() external view returns (uint256) {\r\n        return block.timestamp >= timelock ? 0 : timelock - block.timestamp;\r\n    }\r\n\r\n    /// @notice Devuelve el estado actual del swap.\r\n    /// @return Una cadena de texto que describe el estado (\"Completed\", \"Refunded\", \"Pending\").\r\n    function getSwapStatus() external view returns (string memory) {\r\n        if (withdrawn) return \"Completed\";\r\n        if (refunded) return \"Refunded\";\r\n        return \"Pending\";\r\n    }\r\n}"
    },
    "contracts/SwapFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.24;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\"; // Necesario para interactuar con el token\r\nimport \"./AtomicSwapIntentERC20.sol\"; // Importa el contrato de swap atómico\r\n\r\n/// @title SwapFactory para desplegar y gestionar instancias de AtomicSwapIntentERC20\r\n/// @notice Permite la creación estandarizada de nuevos swaps atómicos ERC-20\r\n///         y centraliza el depósito inicial de tokens del usuario.\r\ncontract SwapFactory {\r\n    address[] public allSwaps; // Almacena las direcciones de todos los contratos de swap creados\r\n\r\n    // Evento que se emite cuando se crea un nuevo contrato de swap\r\n    event SwapCreated(\r\n        address swapAddress,      // Dirección del nuevo contrato de swap\r\n        address indexed creator,  // El usuario que inició la creación del swap (msg.sender de la factory)\r\n        address indexed receiver, // El receptor final de los tokens\r\n        address indexed token,    // La dirección del token ERC-20\r\n        uint256 amount,           // La cantidad de tokens\r\n        uint256 timelockEnd       // El timestamp Unix de finalización del timelock\r\n    );\r\n\r\n    /// @notice Crea una nueva instancia del contrato AtomicSwapIntentERC20.\r\n    ///         El usuario (msg.sender) debe haber APROBADO previamente\r\n    ///         que esta Factory pueda gastar sus 'amount' de 'tokenAddress'.\r\n    /// @param hashlock El hash keccak256 del secreto compartido.\r\n    /// @param timelockSeconds Duración del timelock en segundos.\r\n    /// @param receiver Dirección que recibirá los tokens si presenta el secreto.\r\n    /// @param executor Dirección autorizada para ejecutar el swap (ej: un solver de 1inch Fusion+).\r\n    /// @param tokenAddress Dirección del contrato del token ERC-20 a intercambiar.\r\n    /// @param amount Cantidad de tokens a intercambiar.\r\n    function createSwap(\r\n        bytes32 hashlock,\r\n        uint256 timelockSeconds,\r\n        address receiver,\r\n        address executor,\r\n        address tokenAddress,\r\n        uint256 amount\r\n    ) external {\r\n        // Validaciones iniciales\r\n        require(amount > 0, \"Amount must be greater than zero.\");\r\n        require(receiver != address(0), \"Receiver address required.\");\r\n        require(executor != address(0), \"Executor address required.\");\r\n        require(tokenAddress != address(0), \"Token address required.\");\r\n        require(timelockSeconds > 0, \"Timelock must be positive.\");\r\n\r\n        // Referencia al contrato del token ERC-20\r\n        IERC20 tokenInstance = IERC20(tokenAddress);\r\n\r\n        // Paso 1: Mover los tokens del USUARIO (msg.sender) a la Factory.\r\n        // El usuario debe haber llamado a token.approve(address(this), amount) ANTES de llamar a esta función.\r\n        require(\r\n            tokenInstance.transferFrom(msg.sender, address(this), amount),\r\n            \"Token transfer from user to factory failed. Check allowance.\"\r\n        );\r\n\r\n        // Paso 2: Crear la nueva instancia del contrato AtomicSwapIntentERC20.\r\n        // Pasamos msg.sender como el '_sender' original para el AtomicSwapIntentERC20\r\n        // para que ese contrato sepa quién tiene los derechos de reembolso.\r\n        AtomicSwapIntentERC20 newSwap = new AtomicSwapIntentERC20(\r\n            msg.sender,         // El usuario original que crea el intent\r\n            hashlock,\r\n            timelockSeconds,\r\n            receiver,\r\n            executor,\r\n            tokenAddress,\r\n            amount\r\n        );\r\n\r\n        // Paso 3: Mover los tokens de la Factory al nuevo contrato de swap.\r\n        // Ahora los tokens están en la Factory, y se transfieren al contrato de swap recién creado.\r\n        require(\r\n            tokenInstance.transfer(address(newSwap), amount),\r\n            \"Token transfer from factory to new swap contract failed.\"\r\n        );\r\n\r\n        // Almacenar la dirección del nuevo contrato de swap\r\n        allSwaps.push(address(newSwap));\r\n\r\n        // Emitir evento para registrar la creación del swap\r\n        emit SwapCreated(\r\n            address(newSwap),\r\n            msg.sender,\r\n            receiver,\r\n            tokenAddress,\r\n            amount,\r\n            block.timestamp + timelockSeconds\r\n        );\r\n    }\r\n\r\n    /// @notice Devuelve el número total de contratos de swap creados.\r\n    function getSwapCount() external view returns (uint256) {\r\n        return allSwaps.length;\r\n    }\r\n\r\n    /// @notice Devuelve la dirección de un contrato de swap dado su índice.\r\n    /// @param index El índice del contrato de swap en la lista.\r\n    function getSwapAddress(uint256 index) external view returns (address) {\r\n        require(index < allSwaps.length, \"Invalid index.\");\r\n        return allSwaps[index];\r\n    }\r\n\r\n    /// @notice Devuelve un array con todas las direcciones de los contratos de swap creados.\r\n    function getAllSwaps() external view returns (address[] memory) {\r\n        return allSwaps;\r\n    }\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}